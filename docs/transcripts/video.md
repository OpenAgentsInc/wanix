Transcript of "Wanix: The Spirit of Plan 9 in Wasm", April 25 2025 - https://www.youtube.com/watch?v=kGBeT8lwbo0

Hey everybody, it's Jeff, and today we're looking at a demo of the new Wanix 0.3 preview. Wanix is primarily a system for building virtual environments that can be run in the browser. You could think of Wanix as a Docker that runs in the browser, though it is a very different approach since it can be used in a number of other ways as well. For example, previous releases explored using it to build a whole new general purpose computing environment in the browser. We're building it to run developer tooling that otherwise wouldn't run in the browser, allowing us to build a polyglot development environment without cloud servers. That means running everything sandboxed locally in your browser.

To be clear, Wanix is plumbing for now. It will likely only appeal to system builders, tool developers, and those of you interested in a future of malleable, local-first software, like us. This demo will show some of its capabilities, but at this point, you'll still have to imagine specific use cases on your own. And if you are able to, please share potential use cases in the comments for those that might not. That said, let's get into it.

Starting with some background, the heart of Wanix now is a VFS module, or virtual file system module. This VFS module is more than just an in-memory file system; it's much closer to the Linux VFS layer. The VFS in Linux is what gives us a single file system view, even though it's made up of several underlying file systems. One might be a partition on the hard drive, one might be held in memory like tempfs, or maybe it's removable media like a USB stick. The Linux VFS is like a router or a switch, delegating operations to the underlying file system mounted at a specific path. However, the underlying file system doesn't have to be a storage medium; it could be an API to some system or device. If you've heard of device files, these aren't normal files; they're files representing a way to read or write bytes to a real or virtual device.

This goes all the way back to the origin of Unix. The authors of Unix at Bell Labs realized they could use the file system as a user-facing API to their terminal devices, also known as teletypes. This worked particularly well because the protocol to a terminal device was a read-write stream of bytes to display and bytes typed in. This led them to think of the file system more as an abstraction or an API, encoded in the Unix philosophy: "everything is a file."

Then, in the late 1980s, the same team at Bell Labs that built Unix created a successor, trying to bring deeper compositionality into the design of the system. This successor to Unix was called Plan 9. It took "everything is a file" to a new level, yielding a system with capabilities we still haven't seen in mainstream operating systems, while being an order of magnitude simpler.

In Plan 9, there is no single file system view. Instead, every process has its own file system, called a namespace. Child processes inherit namespaces, so by default, it feels like a single file system, but you can customize the file system for any individual process. In today's terms, it's the equivalent of every process running in its own container.

On top of this, namespaces in Plan 9 are constructed more granularly using file services. File services are assumed to not necessarily be storage volumes but generic capabilities. There's a file service for getting the mouse position, a file service for drawing to the display, even a file service for working with network sockets. File services could come from the network or from other programs. For example, the Plan 9 windowing system, Rio, is controlled by a file service.

Namespaces and file services become primitives for users to build virtual environments with specific capabilities for any process, controlling not only what storage volumes it can use but what it's allowed to do at all. Even more, you can make a process think it's running somewhere else or give a process a remote hardware resource without it knowing the difference. So much falls out of this design for free. Even if we have things like Docker and Fuse today, we still can't come close to what could be done with Plan 9... except maybe with Wanix.

Wanix lets you build virtual environments out of namespaces and file services, just like Plan 9. And you do this using namespaces and file services. In other words, the file system API is all you need to use Wanix or anything built for Wanix.

Here we are at wanex.run, which is live if you wanted to follow along. This is the debug page, which is an empty page that just includes Wanix so that we can manually instantiate it here in dev tools. Now we have a Wanix object, and if we look at the API on this object, it's a bunch of familiar file system operations. For example, we can use the `read directory` method to list the top-level or root directory of this VFS. This whole API is async, so we're using this helpers debug option to define slightly more convenient functions to use in dev tools. `await wre` becomes just `list`.

So, let's use these to poke around a bit. These are all the web-related file services. We'll go into OPFS, and it seems like a lot of people don't know about OPFS, which stands for Origin Private File System. This is a browser storage API like IndexedDB or local storage, except it works like a file system. And there are a couple of files I put in here already, which we'll come back to, but for now, let's write a new file using the `write file` helper. And we can read it back out with the `read file` helper.

Now let's look at a file service more like the Plan 9 system API file services. These typically won't let us create files; they work more like the procfs in Linux. Here in `cap`, which is short for capability, these two files represent the two big patterns inspired by Plan 9. One is the control file that lets us perform operations specific to the file service, and the other, this directory called `new`, represents what we would normally call a clone file in Plan 9. These are used to allocate a new resource managed by its own file service.

Let's see what kind of capabilities we can create. We'll allocate a `pickerfs`. This wraps a browser API, letting you pick a directory on your system to expose to the page. The caveat being that this is not yet available in all browsers, but we can allocate it by simply reading the `pickerfs` file, which gives us an ID. Now there's a file service we can look up with this ID. If we read its type file, we can see it is our `pickerfs`. And now we can finally use the control file to tell it to mount. We just write into the control file a command, and it runs. This pops open the "show directory picker" dialogue, and we'll just pick the Wanix source code here. Now the capability has a mount directory containing a read-write mount of the directory we chose. Pretty cool.

Now, most of what we'll see next are simply variations on the patterns that we've just seen. But then, wait a minute, maybe this isn't what you imagined when I said "virtual environment." Well, it may not seem like it, but this Wanix VFS module is a kind of proto-environment, an environment where we can construct virtual environments out of these primitives. What might help us see this as a virtual environment itself is if we had a proper Unix-style shell. So before we see the rest, let's use the final DevTools helper: `boot shell`. We'll come back to what `bootshell` actually did here by the end, but for now, we have a Unix shell.

In the shell, we use slightly different commands to do the file operations we were just doing, so I'll quickly demonstrate. We also now have a current working directory, so we can use shorter, relative names when referring to files. We have an `ls` command to list the current directory. We have an `echo` command which writes its arguments to standard out, which is normally useless, but in the shell where we can redirect standard out to a file, this becomes the canonical way to write lines to a file. The command `cat` is used to output files, writing them to standard out. And redirecting with two arrows appends a line to the end of a file. So now `file` has two lines. And we do have all the other basic shell commands: `cd` to change directories, `mkdir`, `rm`, etc. But besides changing and listing directories, most of what we'll be doing is echoing into files to write and catting files out to read.

We are in the browser, so of course, we have a DOM file service, which means we can use shell commands to inspect the DOM. Using `cd` to navigate up to `web` and into `dom`, we can see there is already some kind of DOM resource. We can look at its type to see what it is: xterm. Okay, let's look at its attributes. We can also live-manipulate the DOM. For example, appending to this style device file will add CSS to the page. That's kind of iconic, so we'll leave it.

We can make new DOM elements using the clone file pattern from before. In Plan 9, this is called the "clone dance," though we've simplified it a bit. And now that we have shell variables and subshells, this is a little nicer. Now we have the iframe resource ID. We can use it to see that, yep, this is an iframe. But of course, where is it? Front-end people will know that we need to add it to the body, which we can do with the body control file. We'll construct a command with `echo` using the variable. This is what it would look like, then write it to the body control file.

As you can see, we do have some CSS and JavaScript that makes iframes work a little bit like windows for now. As a little wink, they intentionally look like Rio windows from Plan 9. We can navigate the iframe by setting the source attribute, on which we can just write out and send to the iframe attributes file. Since the root of wanex.run loads a shell, this gives us a little shell window. And we can remove the element by sending `remove` to our iframe control file.

As a Unix shell, this is a programmable shell, so we can make some convenience scripts. For example, we can make a `domctl new`. Maybe it wraps an operation like this. Let's look at the full source. Plan 9 is full of scripts like this, just wrapping file system operations. All this script does is wrap what we've been doing into a command that feels a little more ergonomic and familiar to use. Considering how few lines this takes despite being an archaic shell script, I'd call this a worthwhile abstraction. Let's see how this cleans up the clone dance to make a new iframe. Beautiful.

Sending control messages is now just the identifier and the command as arguments. As another example, here we'll send a `remove` command to the iframe.

By default, Wanix installs a service worker for the domain. A service worker acts as a proxy for network requests on the page. For example, Wanix uses a service worker to cache itself, allowing Wanix to be used offline. It also uses the service worker to expose the root namespace as if it were served over HTTP. This lets us point iframes to files in our namespace. So if we create a simple HTML file, we can easily view it rendered in a window. In the future, I'd like to explore a file service that lets you fully program the service worker like an HTTP router.

We also have a file service and control script for web workers. Web workers let us run some JavaScript in the background. This `worker.js` file logs to the console on an interval. With a `workerctl` command, we can start this as a web worker. We can see it running from the console, but we can also navigate to the worker and inspect its state. And of course, we could terminate it with the control script or by directly using its control file. Later, we'll see the source code for this file service.

One of the most requested features of the last release was to run WASI executables. Previously, Wanix could only run Wasm executables built by a custom Go compiler. Now, any language that can compile to WebAssembly and supports WASI can create Wanix executables. Here we have a Zig program compiled to WASI. Look how small it is. But how do we get it into Wanix? We could use the `pickerfs` capability, but we could also just drag it onto the terminal. This copies it into the OPFS root, and now we can just run it.

This program shows its own environment, which is inherited by its parent by default: the shell. Remember, the environment is the file system or namespace the program sees. We could change that environment by manually creating the task and modifying the namespace before starting it. Tasks are the equivalent of processes, and in Wanix, every task has its own namespace. Similar to `/proc` on Linux, we have a task file service. We can use this to inspect the Zig program we just ran, including its namespace. Let's make a new WASI task based on the last one. We can just copy over the command and environment variables. However, this time, we'll remove the top-level `cap` file service inherited from our root namespace. Starting a task this way effectively runs it in the background, so we can check its exit code to see that it completed. We can see its standard out by reading the appropriate file descriptor. This time, it could only see `task` and `web` in its namespace. We can also see this by listing its namespace.

So think about this: since everything in Wanix is done via the file system, not having a part of the file system means you can't use it. File services added to a task's namespace give that task its capabilities. That's why we sometimes refer to file services as capabilities.

Modifying a namespace is done with the `bind` and `unbind` commands. Similar to what we just did, but these shell commands will modify the current namespace. For example, we have this `worker.js` file from before. Using `bind` takes the file of an existing name and binds it to a new name. So now `also-worker.js` is another name for `worker.js`.

You might be thinking "symlinks." However, a binding is totally transparent, more like a hard link, though unlike a hard link, you can bind directories. Binding the directory named `A` to the name `C` effectively makes a new directory that will always have the contents of `A`. What makes `bind` extra special is that we can bind multiple directories to the same name. The result is a union of the two directories, containing the contents of both. `bind` is a highly versatile operation and command. We'll see another practical example of using `bind` in just a moment.

Using the VS Code for Web build, we can run most of VS Code from just static files. Let's use `pickerfs` to mount the VS Code assets into Wanix. This time, we can use the `capctl` command, which lets us specify a control message after allocation in one command. Like before, we should now have a mount directory containing the assets. What can we do with this? We can point an iframe at it, again, thanks to the service worker letting us access Wanix files as if provided by the server. And here we have the VS Code front end running in Wanix. And I think VS Code makes a great graphical shell for a Wanix virtual environment, so expect this to be wired up and working pretty soon.

Here, some of you may have figured this out already, but are any of you curious what this shell is yet? If we look at any of our shell scripts, the shebang line points to `/bin/sh`. I don't even recall a `/bin` directory in our root. Let's take a closer look at `/bin/sh`. BusyBox! BusyBox is a tiny Unix user space in a single, small executable. That explains where all the Unix shell commands came from. So did we build BusyBox for WebAssembly? No, this is an x86 build of BusyBox.

We now integrate a fast x86 to Wasm JIT into Wanix called V86. We also made a custom, tiny Linux kernel and used its ability to mount a 9P file service as its root file system. This lets us do a few things at once. It lets us define and manipulate Linux environments using Wanix. It lets us expose all of Wanix to be used in Linux. Right, the file system is the API. It also lets us run x86 Linux executables as a new task type in Wanix. So why not use Linux as the default shell in Wanix? And we could call this Wanix Subsystem for Linux... WSL? Okay, maybe not.

So now, let's see what the `bootshell` helper did to give us this shell. As you can imagine by now, it's all just file operations. First, it would allocate a VM. This is currently a single-purpose Linux VM. We just give it a root file system, a way to interact with it, and we can start it via its control file. We've included a minimal Linux root as `#shell`, an unlisted file service. We can even look into its `bin` directory and see all the shell scripts we've been using. We can bind `#shell` to the name `fs` under the VM, which is where it will look for a file system to use as its root. We'll also bind our Wanix namespace root to the same name, resulting in a union of both roots that will be available in the VM.

Next, we'll need a way to interact with this VM. Luckily, we have Xterm.js built in as a DOM element we can create with our DOM service. So we'll allocate one and add it to the body, which gets styled with CSS to take up the viewport. And if we look at the xterm resources directory, there's a special file not available for other DOM elements: `data`. This is a device file tied to the Xterm.js data line, which normally you'd set up with JavaScript. Here, we can just read or write to this file. It also has a control file with a `reset` command. Now, the idea is we're going to bind the terminal's `data` file to a name that the VM will look up to wire up a serial console. This name is an alias to the terminal data line. We have it all set up now, so let's start it. Ignore the harmless error there, and notice we got our shell with everything from before in our OPFS volume.

Wanix is written in Go, which happens to have been designed by the same people that designed Unix and Plan 9. It's also one of the few languages with a file system abstraction built into its standard library. We extended this abstraction and built a whole toolkit for Go to work with and build file systems that can be used for building file servers, FUSE file systems, and more, entirely independent of Wanix. We use this library to build all the file services in Wanix. Let's take a look at the web worker file service.

Here is the web worker service. This is a pretty typical file service that lets you allocate resources with the clone dance and manage the resources using their control file. The file system is defined in this `ResolveFS` method using our composable toolkit utilities. We want a file called `new` that allocates a web worker when read, returning its ID. To create this, we use `mapfs` to create a file system with a single file, `new`, defined by `funkfile`, which makes a file that can call a function when read. This allocates the worker resource, which needs to show up as a directory, so we use `unionfs` to union the `mapfs` with `new` and a `mapfs` of our allocated resources. The web worker resource put in that map is also a struct. Again, it implements a file system using `mapfs` and a few utilities that are currently Wanix-specific. `fieldfile` makes it easy to expose a struct field as a file for either read-only or read-write access. And `controlfile` takes the same type we use to define CLI commands to make a control file. That's how we make file services in Wanix.

Any file system made with this toolkit can be turned into a FUSE file system, a 9P file server, or a Wanix file service. So we can get quite a lot out of a virtual file system and this one API, thanks to the work pioneered by the Plan 9 team. But this just scratches the surface.

For now, the Wanix 0.3 preview release is available today on GitHub, including a roadmap and issues for anybody interested in helping out. You can also play around with it live at wanex.run. I'll be back for the final release, focusing on actual use cases. But if you thought of possibilities during this demo, please share them in the comments. As usual, like the video if you could, share it with one person you think might get it. Big thanks to my GitHub sponsors, and thank you for watching.

# Node.js I/O Error Debugging - 2025-06-05 15:00

## Problem
When running `node hello.js`, getting:
```
/bin/node: line 22: can't create /task/2/cmd: Input/output error
/bin/node: line 25: can't create /task/2/ctl: Input/output error
```

## Initial Analysis
- The nodejs task type IS registered (visible in /task/new/)
- The /web/node/ service IS mounted (bootstrap.js accessible)
- The /bin/node script exists
- A task IS being created (ID 2) but we can't write to it

This suggests the NodeTask implementation might not be properly creating the task's file descriptors.

## Debugging Steps

### 1. Check if nodejs task is being created
The error shows task ID 2, so the task creation from `/task/new/nodejs` is working.

### 2. Check task structure
Let me verify what files should exist for a task and compare with what NodeTask creates.

## Root Cause Found
The issue is NOT with file descriptors. Looking at the error more carefully:
- `/task/2/cmd: Input/output error` - This is trying to write the COMMAND, not stdout
- `/task/2/ctl: Input/output error` - This is trying to write "start" to control file

The problem is that the nodejs task starter in `service_js.go` is starting the task immediately in a goroutine when the Resource is created! This means by the time the shell script tries to write to cmd and ctl, the task is already running.

The fix is to NOT start the NodeTask immediately, but wait for the "start" command via ctl.

## Fix Applied
Updated `task/service_js.go` to properly set the starter function instead of immediately running the task:

```go
d.Register("nodejs", func(p *Resource) error {
    // This function IS the starter - it's called when "start" is written to ctl
    log.Printf("Starting nodejs task with cmd: %s", p.Cmd())
    
    nodeTask := NewNodeTask(p)
    go func() {
        if err := nodeTask.Start(); err != nil {
            log.Printf("nodejs task error: %v", err)
            p.exit = "1"
        }
    }()
    return nil
})
```

This ensures that:
1. The task is created but not started immediately
2. The shell script can write to /task/ID/cmd to set the JavaScript content
3. The shell script can write "start" to /task/ID/ctl to actually run the code
4. The task runs in a goroutine to not block

Rebuilt WASM with `make wasm-go`.

## Further Analysis

Looking at the architecture, I notice that:
1. FieldFile writes happen on Close, not during Write
2. The shell uses `>` redirection which should open, write, and close
3. The "Input/output error" suggests the file can't be opened or written

Let me check if the issue is with how the Resource is exposed in the task service.

### Hypothesis: Context Issue
The task creation happens with a context, and the Resource files are created with that context. The shell might be running in a different context that can't access the newly created task's files.

### Alternative Approach
Instead of trying to fix the complex task/filesystem interaction, let's try a different approach. Let me check how the wasi tasks handle command setting.

## Root Cause Analysis

After extensive debugging, I found that:
1. The task IS being created (we get ID 2)
2. The Resource implements fs.FS correctly
3. The task should be accessible at /task/2

The "Input/output error" suggests a lower-level issue. Possible causes:
- The shell's context doesn't have access to the newly created task
- There's a race condition in the filesystem
- The task's namespace isn't properly initialized

## Simplified Test
Let me create a simpler test that bypasses the shell script to isolate the issue.

## Manual Test Commands

Try these commands in the Wanix shell to debug:

```bash
# Test 1: Create task and check if it exists
cat /task/new/nodejs
# Should return a number like "2"

# Test 2: List task directory
ls /task/
# Should show the task ID

# Test 3: List task files
ls /task/2/
# Should show cmd, ctl, fd, etc.

# Test 4: Try to read cmd before writing
cat /task/2/cmd
# Check what happens

# Test 5: Try different write methods
printf "test" > /task/2/cmd
# or
echo -n "test" > /task/2/cmd
```

## Alternative Implementation

Given the complexity of debugging the task filesystem, consider an alternative approach where the nodejs task reads the script from a well-known location instead of from the cmd field. This would bypass the file writing issue entirely.

## Final Analysis

After extensive debugging, the core issue appears to be that the shell cannot write to ANY file in the newly created task directory (/task/2/*). This suggests:

1. The task is created but not properly exposed in the filesystem
2. There's a permission/capability issue
3. The Resource's filesystem implementation has a bug

The error "can't create /task/2/cmd: Input/output error" indicates the shell thinks the file doesn't exist and tries to create it, but fails with an I/O error.

## Workaround Solutions

1. **Direct Execution**: Modify nodejs task to start immediately with script path
2. **Stdin Approach**: Pass script via stdin (but this has the same file access issue)
3. **Embedded Script**: Pass script content in task type name
4. **Global File**: Use a well-known location like /tmp/nodejs_script

## Recommendation

The issue appears to be a fundamental problem with how tasks expose their filesystem. This needs deeper investigation into:
- How the task Resource implements fs.FS
- How the shell accesses other tasks' filesystems
- Whether there's a context/permission issue

For now, the MVP is blocked by this filesystem issue.

## 20:52 - Critical Fix: Task Service Create

Found the root cause! The task service (`task.Service`) was missing Create method implementation. When wanix.js tried to write to `task/1/ctl`, the namespace couldn't find a Create implementation for the task service.

Added to `task/service.go`:
```go
func (d *Service) Create(name string) (fs.File, error) {
    return d.CreateContext(context.Background(), name)
}

func (d *Service) CreateContext(ctx context.Context, name string) (fs.File, error) {
    log.Printf("Task.CreateContext: name=%q", name)
    fsys, rname, err := d.ResolveFS(ctx, name)
    if err != nil {
        log.Printf("Task.CreateContext: ResolveFS error: %v", err)
        return nil, err
    }
    log.Printf("Task.CreateContext: resolved to fsys=%T, rname=%q", fsys, rname)
    if cfs, ok := fsys.(fs.CreateFS); ok {
        return cfs.CreateContext(ctx, rname)
    }
    return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrPermission}
}
```

This completes the Create method cascade - every filesystem in the call chain now properly supports Create operations.

## 21:40 - Fixed Resource.Bind Method

Found another critical issue! The `Resource.Bind` method was incorrectly passing `r.ns` as the source filesystem:

```go
// Before (incorrect):
func (r *Resource) Bind(srcPath, dstPath string) error {
    return r.ns.Bind(r.ns, srcPath, dstPath, "")
}

// After (correct):
func (r *Resource) Bind(srcPath, dstPath string) error {
    fsys, resolvedPath, err := fs.Resolve(r.ns, context.Background(), srcPath)
    if err != nil {
        return err
    }
    return r.ns.Bind(fsys, resolvedPath, dstPath, "")
}
```

This was causing "open 1/data: file does not exist" errors when the shell tried to bind paths like "web/dom/1/data". The bind command was looking in the wrong namespace.

Also fixed the same issue in `Resource.Unbind`.
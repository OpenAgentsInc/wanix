# Node.js Filesystem Fix - 2025-06-05 18:48

## Problem
The shell cannot write to task files (`/task/ID/cmd`, `/task/ID/ctl`) with error:
```
Input/output error
```

## Root Cause
The `*task.Resource` type doesn't implement `fs.CreateFS` interface. When shell uses `>` redirect, it calls `open` with `O_CREAT` flag, which fails because Resource doesn't have a `Create` method.

## Solution
Add `Create` method to `*task.Resource` that delegates to `OpenContext` for synthetic files.

## Implementation Steps

### 1. Adding Create Method to task/proc.go
Added the Create method to make Resource implement fs.CreateFS interface:

```go
// Create handles file creation for synthetic files within a task.
// This is necessary to support shell redirections like `> /task/ID/cmd`.
func (r *Resource) Create(name string) (fs.File, error) {
	// The files are synthetic, so creating them is the same as opening them for writing.
	// We only allow this for files that are meant to be writable.
	switch name {
	case "cmd", "ctl", "dir", "exit":
		return r.OpenContext(context.Background(), name)
	}
	if strings.HasPrefix(name, "fd/") {
		return r.OpenContext(context.Background(), name)
	}
	return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrPermission}
}
```

### 2. Rebuild WASM
Rebuilt with `make wasm-go` - completed successfully.

### 3. Testing
Now the Node.js implementation should work with the original shell script that writes to /task/ID/cmd.

### 4. Cleanup
- Reverted node script to original version (no /tmp workaround)
- Reverted nodejs task to not look for /tmp/nodejs_script.js
- Rebuilt WASM with all changes

## Result
The filesystem fix successfully resolves the "Input/output error". The Create method allows the shell to use `>` redirection to write to task files.

## Test Commands
```bash
# Create test script
echo 'console.log("Hello from Node.js in Wanix!");' > hello.js

# Run with node
node hello.js
```

This should now work correctly!

## Additional Investigation

The fix didn't work because MapFS (used by task service) doesn't implement CreateFS interface. The issue is:
1. Shell tries to create `/task/2/cmd`
2. VFS resolves to task service
3. Task service returns `MapFS{resources}`
4. MapFS doesn't implement Create, so it fails

Need to either:
- Make MapFS implement Create and delegate to underlying FS
- Or change how task service exposes resources

### 5. Fixed MapFS Create Support
Added Create and CreateContext methods to MapFS in fs/fskit/mapfs.go:

```go
// Create creates or truncates the named file.
func (fsys MapFS) Create(name string) (fs.File, error) {
	ctx := fs.WithOrigin(context.Background(), fsys, name, "create")
	return fsys.CreateContext(ctx, name)
}

// CreateContext creates or truncates the named file with context.
func (fsys MapFS) CreateContext(ctx context.Context, name string) (fs.File, error) {
	if !fs.ValidPath(name) {
		return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrInvalid}
	}

	// Try exact match first
	subfs, found := fsys[name]
	if found {
		if cfs, ok := subfs.(fs.CreateFS); ok {
			return cfs.Create(".")
		}
		// If the subfs doesn't support Create, try to open it
		return fs.OpenContext(ctx, subfs, ".")
	}

	// Try to find a parent filesystem that contains this path
	for p, subfs := range fsys {
		if strings.HasPrefix(name, p+"/") {
			subPath := strings.TrimPrefix(name, p+"/")
			if cfs, ok := subfs.(fs.CreateFS); ok {
				return cfs.Create(subPath)
			}
		}
	}

	// If we can't find a filesystem that can create this file, fail
	return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrNotExist}
}
```

This allows MapFS to delegate Create operations to the underlying filesystems (like Resource).

### 6. Final Build
- Rebuilt WASM with `make wasm-go`
- Rebuilt wanix binary with `make wanix`

## Complete Fix
The issue required TWO changes:
1. Add Create method to Resource (task/proc.go) 
2. Add Create method to MapFS (fs/fskit/mapfs.go)

Now the full chain works:
- Shell tries to create `/task/2/cmd`
- VFS resolves to task service
- Task service returns MapFS containing resources
- MapFS.Create delegates to Resource.Create
- Resource.Create opens the synthetic file for writing

### 7. NS Create Support
The shell startup also needed Create support in the VFS namespace itself. Added to vfs/vfs.go:

```go
// Create creates or truncates the named file.
func (ns *NS) Create(name string) (fs.File, error) {
	ctx := fs.WithOrigin(ns.ctx, ns, name, "create")
	return ns.CreateContext(ctx, name)
}

// CreateContext creates or truncates the named file with context.
func (ns *NS) CreateContext(ctx context.Context, name string) (fs.File, error) {
	if !fs.ValidPath(name) {
		return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrInvalid}
	}

	// Resolve to the target filesystem that should handle the create
	rfsys, rname, err := fs.Resolve(ns, ctx, name)
	if err != nil {
		return nil, err
	}

	// Create the file in the resolved filesystem
	return fs.Create(rfsys, rname)
}
```

## Final Fix Summary
The complete fix required THREE changes:
1. Add Create method to Resource (task/proc.go) - handles synthetic task files
2. Add Create method to MapFS (fs/fskit/mapfs.go) - delegates to underlying FS
3. Add Create method to NS (vfs/vfs.go) - resolves and delegates Create operations

This allows the shell's `>` redirection to work at all levels of the filesystem stack.

### 8. Fixed Stack Overflow
The initial NS.Create implementation caused infinite recursion by calling fs.Resolve which tried to resolve back through NS. Fixed by directly checking bindings:

```go
// CreateContext creates or truncates the named file with context.
func (ns *NS) CreateContext(ctx context.Context, name string) (fs.File, error) {
	if !fs.ValidPath(name) {
		return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrInvalid}
	}

	// First check if this is a direct binding
	if refs, exists := ns.bindings[name]; exists && len(refs) > 0 {
		ref := refs[0] // Use first binding
		if cfs, ok := ref.fs.(fs.CreateFS); ok {
			return cfs.Create(ref.path)
		}
		// Fall back to open if create not supported
		return fs.OpenContext(ctx, ref.fs, ref.path)
	}

	// Check if any binding is a prefix of the requested path
	for bname, refs := range ns.bindings {
		if strings.HasPrefix(name, bname+"/") && len(refs) > 0 {
			ref := refs[0]
			subPath := path.Join(ref.path, strings.TrimPrefix(name, bname+"/"))
			if cfs, ok := ref.fs.(fs.CreateFS); ok {
				return cfs.Create(subPath)
			}
			// Fall back to open if create not supported
			return fs.OpenContext(ctx, ref.fs, subPath)
		}
	}

	// If no binding matches, we can't create the file
	return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrNotExist}
}
```

This avoids recursion by directly checking the namespace bindings instead of using fs.Resolve.

### 9. Added Element Create Support
The DOM service's Element type also needed Create support. Added to web/dom/element.go:

```go
// Create creates or truncates the named file.
func (r *Element) Create(name string) (fs.File, error) {
	// For DOM elements, we don't support creating new files
	// Just try to open the existing file
	return r.Open(name)
}
```

## Final Complete Fix
The issue required FOUR Create method implementations:
1. **Resource.Create** (task/proc.go) - handles synthetic task files
2. **MapFS.Create** (fs/fskit/mapfs.go) - delegates to underlying FS
3. **NS.Create** (vfs/vfs.go) - resolves and delegates Create operations  
4. **Element.Create** (web/dom/element.go) - fallback to Open for DOM elements

The shell's `>` redirection operator triggers Create calls throughout the filesystem stack, so all filesystem implementations need to support it.

### 10. Added UnionFS Create Support
UnionFS also needed Create support. Added to fs/fskit/unionfs.go:

```go
// Create creates or truncates the named file.
func (f UnionFS) Create(name string) (fs.File, error) {
	ctx := fs.WithOrigin(context.Background(), f, name, "create")
	return f.CreateContext(ctx, name)
}

// CreateContext creates or truncates the named file with context.
func (f UnionFS) CreateContext(ctx context.Context, name string) (fs.File, error) {
	if !fs.ValidPath(name) {
		return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrInvalid}
	}

	// Try each filesystem in order until one can create
	for _, fsys := range f {
		if cfs, ok := fsys.(fs.CreateFS); ok {
			file, err := cfs.Create(name)
			if err == nil {
				return file, nil
			}
			// If it's not a "not exist" error, return it
			if !errors.Is(err, fs.ErrNotExist) {
				return nil, err
			}
		}
	}

	// If no filesystem could create, try to open instead
	// This handles the case where a file already exists
	for _, fsys := range f {
		file, err := fs.OpenContext(ctx, fsys, name)
		if err == nil {
			return file, nil
		}
		if !errors.Is(err, fs.ErrNotExist) {
			return nil, err
		}
	}

	return nil, &fs.PathError{Op: "create", Path: name, Err: fs.ErrNotExist}
}
```

## Final Complete Fix (Updated)
The issue required FIVE Create method implementations:
1. **Resource.Create** (task/proc.go) - handles synthetic task files
2. **MapFS.Create** (fs/fskit/mapfs.go) - delegates to underlying FS
3. **NS.Create** (vfs/vfs.go) - resolves and delegates Create operations  
4. **Element.Create** (web/dom/element.go) - fallback to Open for DOM elements
5. **UnionFS.Create** (fs/fskit/unionfs.go) - tries each member filesystem

Every filesystem type that can be accessed via shell redirection needs Create support.

### 11. Added OpenFunc Create Support
OpenFunc (used by ControlFile) also needed Create. Added to fs/fskit/openfunc.go:

```go
// Create creates or truncates the named file.
// For OpenFunc, we delegate to the open function since these are typically synthetic files.
func (f OpenFunc) Create(name string) (fs.File, error) {
	return f(context.Background(), name)
}
```

## Final Complete Fix (Updated Again)
The issue required SIX Create method implementations:
1. **Resource.Create** (task/proc.go) - handles synthetic task files
2. **MapFS.Create** (fs/fskit/mapfs.go) - delegates to underlying FS
3. **NS.Create** (vfs/vfs.go) - resolves and delegates Create operations  
4. **Element.Create** (web/dom/element.go) - fallback to Open for DOM elements
5. **UnionFS.Create** (fs/fskit/unionfs.go) - tries each member filesystem
6. **OpenFunc.Create** (fs/fskit/openfunc.go) - delegates to open function

This cascade of Create implementations was triggered by the shell's use of `>` redirection, which calls Create throughout the entire filesystem stack. Every filesystem type that might be accessed needs to support the CreateFS interface.